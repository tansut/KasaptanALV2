{"version":3,"sources":["../src/lib/authorizationToken.ts"],"names":[],"mappings":"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","file":"authorizationToken.js","sourcesContent":["import * as http from './http';\nimport * as _ from 'lodash';\nimport * as moment from 'moment';\nimport * as crypto from 'crypto';\nimport RefreshToken from '../db/models/refreshToken';\nimport User from '../db/models/user';\n\n\ninterface encrypytionData {\n    tag: Buffer,\n    encryptedData: string\n}\n\nexport interface IEncryptedAccessTokenData {\n    tag: string;\n    tokenData: string;\n}\n\nexport interface IAccessTokenData {\n    userId: number;\n    expiration_time: Date;\n    props: any[];\n}\n\nexport interface IRefreshTokenData {\n    access_token: IEncryptedAccessTokenData;\n    userId: number;\n    tokenId: string;\n    expire_time: Date;\n}\n\n\nexport interface IEncryptedRefreshTokenData {\n    refresh_token: string;\n}\n\nclass AuthorizationTokenController {\n    private genericCipherAlgorithm = 'aes-256-ctr';\n    private cipherAlgorithm = 'aes-256-gcm';\n    private genericTokenKey = '3zTvzr3p67vC61kmd54rIYu1545x4TlY';\n    private genericTokenIV = '60ih0h6vcoEa';\n\n    private convertUtfStringToBuffer(input: string): Buffer {\n        return Buffer.from(input, 'utf8');\n    }\n\n    private convertBufferToUtfString(input: Buffer): string {\n        return input.toString('utf8');\n    }\n\n    private encryptGeneric(item: Object): string {\n        var encryptionString = JSON.stringify(item);\n        var cipher = crypto.createCipher(this.genericCipherAlgorithm, this.genericTokenKey);\n        var encrypted = cipher.update(encryptionString, 'utf8', 'hex');\n        return encrypted;\n    }\n\n    private decryptGeneric(encrypted: string): Object {\n        var cipher = crypto.createDecipher(this.genericCipherAlgorithm, this.genericTokenKey);\n        var decrypted = cipher.update(encrypted, 'hex', 'utf8');\n        return JSON.parse(decrypted);\n    }\n\n    private encrypt(item: Object, iv: string): encrypytionData {\n        var encryptionString = JSON.stringify(item);\n        var cipher = crypto.createCipheriv(this.cipherAlgorithm, this.genericTokenKey, iv);\n        var encrypted = cipher.update(encryptionString, 'utf8', 'hex');\n        encrypted += cipher.final('hex');\n        var tag = (<any>cipher).getAuthTag();\n        return { tag: tag, encryptedData: encrypted };\n    }\n\n    private decrypt(encryptedData: string, tag: Buffer, iv: string): any {\n        var deChipher = crypto.createDecipheriv(this.cipherAlgorithm, this.genericTokenKey, iv);\n        (<any>deChipher).setAuthTag(tag);\n        var decryptedToken = deChipher.update(encryptedData, 'hex', 'utf8');\n        decryptedToken += deChipher.final('utf8');\n        return JSON.parse(decryptedToken);\n    }\n\n    encryptAccessToken(tokenData: IAccessTokenData): string {\n        var encryption = this.encryptGeneric(tokenData);\n        return encryption;\n    }\n\n    encryptRefreshToken(userId: number, access_token: IAccessTokenData): Promise<string> {\n        return new Promise((resolve, reject) => {\n            User.findByPk(userId).then((res) => {\n                if (!res) {\n                    reject(new http.NotFoundError(\"User not found\"));\n                    return;\n                }\n                var encryptAccessToken = this.encrypt(access_token, res.ivCode);\n                var tagDataString = this.convertBufferToUtfString(encryptAccessToken.tag);\n                var encryptedAccessToken = <IEncryptedAccessTokenData>{ tokenData: encryptAccessToken.encryptedData };\n                var refreshToken = <IRefreshTokenData>{\n                    access_token: encryptedAccessToken,\n                    expire_time: moment().add(1, 'year').toDate(),\n                    userId: userId\n                }\n\n                var refreshTokenDocument = <RefreshToken>{\n                    userId: userId,\n                    token: encryptedAccessToken.tokenData,\n                    tag: encryptAccessToken.tag\n                };\n\n                RefreshToken.create(refreshTokenDocument, { isNewRecord: true }).then((createdDocument) => {\n                    refreshToken.tokenId = createdDocument.id.toString();\n\n                    var encryptedRefreshToken = this.encryptGeneric(refreshToken);\n\n                    resolve(encryptedRefreshToken);\n                }).catch((err) => {\n                    reject(new Error(\"Refresh token couldn't be created\"));\n                    return;\n                });\n            });\n        });\n    }\n\n    decryptAccessToken(accessTokenData: string): IAccessTokenData {\n        var decryptedData = <IAccessTokenData>this.decryptGeneric(accessTokenData);\n        return decryptedData;\n    }\n\n    // decryptRefreshToken(refreshTokenData: string) {\n    //     var refreshTokenUnDecrypted = <IRefreshTokenData>this.decryptGeneric(refreshTokenData);\n    //     var userCall = UserModel.findById(refreshTokenUnDecrypted.userId);\n    //     var tokenCall = RefreshTokenModel.findById(refreshTokenUnDecrypted.tokenId);\n\n    //     return new Promise((resolve, reject) => {\n    //         Promise.all<any>([userCall, tokenCall]).then((retrieveData: any) => {\n    //             var user = retrieveData[0];\n    //             var token = retrieveData[1];\n    //             if (!token || !user) {\n    //                 reject(\"Refresh token is invalid or used already\");\n    //                 return;\n    //             }\n    //             try {\n    //                 var userAccessToken = <IAccessTokenData>this.decrypt(refreshTokenUnDecrypted.access_token.tokenData, token.tag, user.ivCode);\n    //                 if (userAccessToken.userId == token.userId) {\n    //                     RefreshTokenModel.remove(token).then(() => {\n    //                         resolve(user);\n    //                     }).catch((err) => {\n    //                         reject(err);\n    //                     });\n    //                 } else {\n    //                     reject(\"Refresh Token Is Modified From Outside Environment.\");\n    //                 }\n    //             } catch (e) {\n    //                 reject(\"Token does not match\");\n    //             }\n\n    //         }).catch((err) => {\n    //             reject(err);\n    //         });\n    //     });\n    // }\n}\n\n\n/*\nUsage of tokens :\n    access_token\nIncoming Token Data (JSON) : {\n                    tag : self decryption tag,\ntokenData (generic encrypted) : {\n                    Includes User Id,\n                Expiration Time Of Token Itself, (30 minutes default),\n                other props : any[]\n            }\n        }\n\n        refresh_token\nIf Incoming Token Data Fails : {\n                    Client sends refresh token,\nRefresh token includes : {\n                    tokenId : Self decryption tag,\nrefresh_token : (generic encrypted) {\n                    access_token : (private encrypted)\n                Refresh token Id (private encrypted),\n                Expiration time of refresh token Itself, (1 year default)\n            }\n        }\n        Refresh token regenerated. Old one expires\n        New access token generated for refresh token (expire time changes)\n        Sends client side new access_token along with refresh token\n    }\n\n */\n\nexport default new AuthorizationTokenController();\n\n"],"sourceRoot":"../../src/"}